<!DOCTYPE html>

<html>
<head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">

<title>module Parslet::Accelerator - parslet-1.7.0 Documentation</title>

<link type="text/css" media="screen" href="../rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "../";
</script>

<script type="text/javascript" charset="utf-8" src="../js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/navigation.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/search_index.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/search.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/searcher.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/darkfish.js"></script>


<body id="top" class="module">
<nav id="metadata">
  <nav id="home-section" class="section">
  <h3 class="section-header">
    <a href="../index.html">Home</a>
    <a href="../table_of_contents.html#classes">Classes</a>
    <a href="../table_of_contents.html#methods">Methods</a>
  </h3>
</nav>


  <nav id="search-section" class="section project-section" class="initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <h3 class="section-header">
      <input type="text" name="search" placeholder="Search" id="search-field"
             title="Type to search, Up and Down to navigate, Enter to load">
    </h3>
  </form>

  <ul id="search-results" class="initially-hidden"></ul>
</nav>


  

  <div id="file-metadata">
    <nav id="file-list-section" class="section">
  <h3 class="section-header">Defined In</h3>
  <ul>
    <li>lib/parslet/accelerator.rb
    <li>lib/parslet/accelerator/application.rb
    <li>lib/parslet/accelerator/engine.rb
  </ul>
</nav>

    
  </div>

  <div id="class-metadata">
    
    
    
    
    <!-- Method Quickref -->
<nav id="method-list-section" class="section">
  <h3 class="section-header">Methods</h3>

  <ul class="link-list">
    
    <li ><a href="#method-i-any">#any</a>
    
    <li ><a href="#method-i-apply">#apply</a>
    
    <li ><a href="#method-i-match">#match</a>
    
    <li ><a href="#method-i-re">#re</a>
    
    <li ><a href="#method-i-rule">#rule</a>
    
    <li ><a href="#method-i-str">#str</a>
    
  </ul>
</nav>

  </div>

  <div id="project-metadata">
    <nav id="fileindex-section" class="section project-section">
  <h3 class="section-header">Pages</h3>

  <ul>
  
    <li class="file"><a href="../README.html">README</a>
  
  </ul>
</nav>

    <nav id="classindex-section" class="section project-section">
  <h3 class="section-header">Class and Module Index</h3>

  <ul class="link-list">
  
    <li><a href="../Object.html">Object</a>
  
    <li><a href="../Parslet.html">Parslet</a>
  
    <li><a href="../Parslet/Accelerator.html">Parslet::Accelerator</a>
  
    <li><a href="../Parslet/Accelerator/Application.html">Parslet::Accelerator::Application</a>
  
    <li><a href="../Parslet/Accelerator/Apply.html">Parslet::Accelerator::Apply</a>
  
    <li><a href="../Parslet/Accelerator/Engine.html">Parslet::Accelerator::Engine</a>
  
    <li><a href="../Parslet/Accelerator/Expression.html">Parslet::Accelerator::Expression</a>
  
    <li><a href="../Parslet/Atoms.html">Parslet::Atoms</a>
  
    <li><a href="../Parslet/Atoms/Alternative.html">Parslet::Atoms::Alternative</a>
  
    <li><a href="../Parslet/Atoms/Base.html">Parslet::Atoms::Base</a>
  
    <li><a href="../Parslet/Atoms/CanFlatten.html">Parslet::Atoms::CanFlatten</a>
  
    <li><a href="../Parslet/Atoms/Capture.html">Parslet::Atoms::Capture</a>
  
    <li><a href="../Parslet/Atoms/Context.html">Parslet::Atoms::Context</a>
  
    <li><a href="../Parslet/Atoms/DSL.html">Parslet::Atoms::DSL</a>
  
    <li><a href="../Parslet/Atoms/Dynamic.html">Parslet::Atoms::Dynamic</a>
  
    <li><a href="../Parslet/Atoms/Entity.html">Parslet::Atoms::Entity</a>
  
    <li><a href="../Parslet/Atoms/Infix.html">Parslet::Atoms::Infix</a>
  
    <li><a href="../Parslet/Atoms/Lookahead.html">Parslet::Atoms::Lookahead</a>
  
    <li><a href="../Parslet/Atoms/Named.html">Parslet::Atoms::Named</a>
  
    <li><a href="../Parslet/Atoms/Precedence.html">Parslet::Atoms::Precedence</a>
  
    <li><a href="../Parslet/Atoms/Re.html">Parslet::Atoms::Re</a>
  
    <li><a href="../Parslet/Atoms/Repetition.html">Parslet::Atoms::Repetition</a>
  
    <li><a href="../Parslet/Atoms/Scope.html">Parslet::Atoms::Scope</a>
  
    <li><a href="../Parslet/Atoms/Sequence.html">Parslet::Atoms::Sequence</a>
  
    <li><a href="../Parslet/Atoms/Str.html">Parslet::Atoms::Str</a>
  
    <li><a href="../Parslet/Cause.html">Parslet::Cause</a>
  
    <li><a href="../Parslet/ClassMethods.html">Parslet::ClassMethods</a>
  
    <li><a href="../Parslet/Context.html">Parslet::Context</a>
  
    <li><a href="../Parslet/DelayedMatchConstructor.html">Parslet::DelayedMatchConstructor</a>
  
    <li><a href="../Parslet/ErrorReporter.html">Parslet::ErrorReporter</a>
  
    <li><a href="../Parslet/ErrorReporter/Contextual.html">Parslet::ErrorReporter::Contextual</a>
  
    <li><a href="../Parslet/ErrorReporter/Deepest.html">Parslet::ErrorReporter::Deepest</a>
  
    <li><a href="../Parslet/ErrorReporter/Tree.html">Parslet::ErrorReporter::Tree</a>
  
    <li><a href="../Parslet/Expression.html">Parslet::Expression</a>
  
    <li><a href="../Parslet/Expression/Treetop.html">Parslet::Expression::Treetop</a>
  
    <li><a href="../Parslet/Expression/Treetop/Parser.html">Parslet::Expression::Treetop::Parser</a>
  
    <li><a href="../Parslet/Expression/Treetop/Transform.html">Parslet::Expression::Treetop::Transform</a>
  
    <li><a href="../Parslet/Graphable.html">Parslet::Graphable</a>
  
    <li><a href="../Parslet/GraphvizVisitor.html">Parslet::GraphvizVisitor</a>
  
    <li><a href="../Parslet/ParseFailed.html">Parslet::ParseFailed</a>
  
    <li><a href="../Parslet/Parser.html">Parslet::Parser</a>
  
    <li><a href="../Parslet/Parser/PrettyPrinter.html">Parslet::Parser::PrettyPrinter</a>
  
    <li><a href="../Parslet/Parser/Visitors.html">Parslet::Parser::Visitors</a>
  
    <li><a href="../Parslet/Parser/Visitors/Citrus.html">Parslet::Parser::Visitors::Citrus</a>
  
    <li><a href="../Parslet/Parser/Visitors/Treetop.html">Parslet::Parser::Visitors::Treetop</a>
  
    <li><a href="../Parslet/Pattern.html">Parslet::Pattern</a>
  
    <li><a href="../Parslet/Pattern/SequenceBind.html">Parslet::Pattern::SequenceBind</a>
  
    <li><a href="../Parslet/Pattern/SimpleBind.html">Parslet::Pattern::SimpleBind</a>
  
    <li><a href="../Parslet/Pattern/SubtreeBind.html">Parslet::Pattern::SubtreeBind</a>
  
    <li><a href="../Parslet/Position.html">Parslet::Position</a>
  
    <li><a href="../Parslet/Scope.html">Parslet::Scope</a>
  
    <li><a href="../Parslet/Scope/Binding.html">Parslet::Scope::Binding</a>
  
    <li><a href="../Parslet/Scope/NotFound.html">Parslet::Scope::NotFound</a>
  
    <li><a href="../Parslet/Slice.html">Parslet::Slice</a>
  
    <li><a href="../Parslet/Source.html">Parslet::Source</a>
  
    <li><a href="../Parslet/Source/LineCache.html">Parslet::Source::LineCache</a>
  
    <li><a href="../Parslet/Source/RangeSearch.html">Parslet::Source::RangeSearch</a>
  
    <li><a href="../Parslet/Transform.html">Parslet::Transform</a>
  
    <li><a href="../RSpec.html">RSpec</a>
  
  </ul>
</nav>

  </div>
</nav>

<div id="documentation">
  <h1 class="module">module Parslet::Accelerator</h1>

  <div id="description" class="description">
    
<p>Optimizes the parsers by pattern matching on the parser atoms and replacing
matches with better versions. See the file qed/accelerators.md for a more
in-depth description.</p>

<p>Example:</p>

<pre>quote = str(&#39;&quot;&#39;)
parser = quote &gt;&gt; (quote.absent? &gt;&gt; any).repeat &gt;&gt; quote

A = Accelerator # for making what follows a bit shorter
optimized_parser = A.apply(parser, 
  A.rule( (A.str(:x).absent? &gt;&gt; A.any).repeat ) { GobbleUp.new(x) })

optimized_parser.parse(&#39;&quot;Parsing is now fully optimized! (tm)&quot;&#39;)</pre>

<p>@api private</p>

  </div><!-- description -->

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    

    

    <!-- Methods -->
    
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Public Instance Methods</h3>

    
      <div id="method-i-any" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">any</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns a match expression that will match `any` parslet atoms.</p>

<p>@return [Parslet::Accelerator::Expression]</p>
          
          

          
          <div class="method-source-code" id="any-source">
            <pre><span class="ruby-comment"># File lib/parslet/accelerator.rb, line 107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">any</span>
  <span class="ruby-constant">Expression</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">:re</span>, <span class="ruby-string">&quot;.&quot;</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- any-source -->
          
        </div>

        

        
      </div><!-- any-method -->

    
      <div id="method-i-apply" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">apply</span><span
            class="method-args">(atom, *rules)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Given a parslet atom and a set of rules, tries to match the rules 
recursively through the parslet atom. Once a rule could be matched,  its
action block will be called.</p>

<p>Example:</p>

<pre>quote = str(&#39;&quot;&#39;)
parser = quote &gt;&gt; (quote.absent? &gt;&gt; any).repeat &gt;&gt; quote

A = Accelerator # for making what follows a bit shorter
optimized_parser = A.apply(parser, 
  A.rule( (A.str(:x).absent? &gt;&gt; A.any).repeat ) { GobbleUp.new(x) })

optimized_parser.parse(&#39;&quot;Parsing is now fully optimized! (tm)&quot;&#39;)</pre>

<p>@param atom [Parslet::Atoms::Base] a parser to optimize @param *rules
[Parslet::Accelerator::Rule] rules produced by .rule @return
[Parslet::Atoms::Base] optimized parser</p>
          
          

          
          <div class="method-source-code" id="apply-source">
            <pre><span class="ruby-comment"># File lib/parslet/accelerator.rb, line 155</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">apply</span> <span class="ruby-identifier">atom</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">rules</span>
  <span class="ruby-constant">Application</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">atom</span>, <span class="ruby-identifier">rules</span>).<span class="ruby-identifier">call</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- apply-source -->
          
        </div>

        

        
      </div><!-- apply-method -->

    
      <div id="method-i-match" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">match</span><span
            class="method-args">(atom, expr)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Given a parslet atom and an expression, will determine if the expression
matches the atom. If successful, returns the bindings into the pattern that
were made. If no bindings had to be made to make the match successful,  the
empty hash is returned.</p>

<p>@param atom [Parslet::Atoms::Base] parslet atom to match against @param
expr [Parslet::Accelerator::Expression] expression to match @return [nil,
Hash] bindings for the match, nil on failure</p>
          
          

          
          <div class="method-source-code" id="match-source">
            <pre><span class="ruby-comment"># File lib/parslet/accelerator.rb, line 120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">match</span> <span class="ruby-identifier">atom</span>, <span class="ruby-identifier">expr</span>
  <span class="ruby-identifier">engine</span> = <span class="ruby-constant">Engine</span>.<span class="ruby-identifier">new</span>

  <span class="ruby-keyword">return</span> <span class="ruby-identifier">engine</span>.<span class="ruby-identifier">bindings</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">engine</span>.<span class="ruby-identifier">match</span>(<span class="ruby-identifier">atom</span>, <span class="ruby-identifier">expr</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- match-source -->
          
        </div>

        

        
      </div><!-- match-method -->

    
      <div id="method-i-re" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">re</span><span
            class="method-args">(variable, *constraints)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns a match expression that will match `match` parslet atoms.</p>

<p>@return [Parslet::Accelerator::Expression]</p>
          
          

          
          <div class="method-source-code" id="re-source">
            <pre><span class="ruby-comment"># File lib/parslet/accelerator.rb, line 99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">re</span> <span class="ruby-identifier">variable</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">constraints</span>
  <span class="ruby-constant">Expression</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">:re</span>, <span class="ruby-identifier">variable</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">constraints</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- re-source -->
          
        </div>

        

        
      </div><!-- re-method -->

    
      <div id="method-i-rule" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">rule</span><span
            class="method-args">(expression, &action)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Constructs an accelerator rule. A rule is a matching expression and the
code that should be executed once the expression could be bound to a 
parser.</p>

<p>Example:</p>

<pre>Accelerator.rule(Accelerator.any) { Parslet.match(&#39;.&#39;) }</pre>
          
          

          
          <div class="method-source-code" id="rule-source">
            <pre><span class="ruby-comment"># File lib/parslet/accelerator.rb, line 133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">rule</span> <span class="ruby-identifier">expression</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">action</span>
  [<span class="ruby-identifier">expression</span>, <span class="ruby-identifier">action</span>]
<span class="ruby-keyword">end</span></pre>
          </div><!-- rule-source -->
          
        </div>

        

        
      </div><!-- rule-method -->

    
      <div id="method-i-str" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">str</span><span
            class="method-args">(variable, *constraints)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns a match expression that will match `str` parslet atoms.</p>

<p>@return [Parslet::Accelerator::Expression]</p>
          
          

          
          <div class="method-source-code" id="str-source">
            <pre><span class="ruby-comment"># File lib/parslet/accelerator.rb, line 91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">str</span> <span class="ruby-identifier">variable</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">constraints</span>
  <span class="ruby-constant">Expression</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">:str</span>, <span class="ruby-identifier">variable</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">constraints</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- str-source -->
          
        </div>

        

        
      </div><!-- str-method -->

    
    </section><!-- public-instance-method-details -->
  
  </section><!-- 5Buntitled-5D -->

</div><!-- documentation -->


<footer id="validator-badges">
  <p><a href="http://validator.w3.org/check/referer">[Validate]</a>
  <p>Generated by <a href="https://github.com/rdoc/rdoc">RDoc</a> 4.0.0.
  <p>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish Rdoc Generator</a> 3.
</footer>

