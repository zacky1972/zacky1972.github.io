var search_data = {"index":{"searchIndex":["object","parslet","accelerator","application","apply","engine","expression","atoms","alternative","base","canflatten","capture","context","dsl","dynamic","entity","infix","lookahead","named","precedence","re","repetition","scope","sequence","str","cause","classmethods","context","delayedmatchconstructor","errorreporter","contextual","deepest","tree","expression","treetop","parser","transform","graphable","graphvizvisitor","parsefailed","parser","prettyprinter","visitors","citrus","treetop","pattern","sequencebind","simplebind","subtreebind","position","scope","binding","notfound","slice","source","linecache","rangesearch","transform","rspec","+()","<=>()","==()",">>()",">>()",">>()","[]()","[]()","[]()","[]=()","[]=()","abort()","absent?()","absent?()","absnt?()","accept()","accept()","accept()","accept()","accept()","accept()","accept()","accept()","accept()","accept()","any()","any()","any()","append_prefix()","apply()","apply()","apply()","apply()","apply()","apply()","as()","as()","ascii_tree()","bind()","bind_type_name()","bound?()","bytepos()","bytepos=()","cached?()","cached?()","cached?()","call()","call_on_match()","can_bind?()","can_bind?()","can_bind?()","capture()","catch_error()","charpos()","chars_left()","chars_until()","children()","consume()","deepest()","deepest_child()","deferred()","downwards()","dynamic()","dynamic()","element_match()","element_match_ary_single()","element_match_binding()","element_match_hash()","err()","err()","err()","err()","err_at()","err_at()","err_at()","escape()","exp()","exp()","find_mid()","flatten()","flatten_repetition()","flatten_sequence()","foldl()","format()","graph()","included()","infix_expression()","infix_expression()","inherited()","inspect()","inspect()","inspect()","join_or_new()","lbound()","length()","line_and_column()","line_and_column()","line_and_column()","lookup()","lookup()","mangle_name()","match()","match()","match()","match()","match()","match()","match()","match()","match_operation()","matches?()","maybe()","merge_fold()","meta_def()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","node()","offset()","parse()","parse()","parse_with_debug()","parslet()","pop()","pos()","precedence()","precedence_climb()","present?()","present?()","pretty_print()","produce_return_value()","produce_tree()","prsnt?()","push()","raise()","raise_not_implemented()","re()","recurse()","recurse_array()","recurse_hash()","recursive_ascii_tree()","repeat()","repeat()","reset()","root()","rule()","rule()","rule()","rule()","rule()","rules()","rules()","scan_for_line_endings()","scope()","scope()","scope()","sequence()","sequence()","set()","set_label()","setup_and_apply()","simple()","simple()","size()","spaced()","str()","str()","str()","subtree()","subtree()","succ()","succ()","succ()","succ()","succ()","to_citrus()","to_f()","to_i()","to_int()","to_parslet()","to_s()","to_s()","to_s()","to_s_inner()","to_s_inner()","to_s_inner()","to_s_inner()","to_s_inner()","to_s_inner()","to_s_inner()","to_s_inner()","to_s_inner()","to_s_inner()","to_s_inner()","to_s_inner()","to_s_inner()","to_slice()","to_str()","to_sym()","to_treetop()","transform()","transform()","transform_elt()","try()","try()","try()","try()","try()","try()","try()","try()","try()","try()","try()","try_bind()","try_with_cache()","unwrap()","update_label()","variable_name()","visit_alternative()","visit_alternative()","visit_alternative()","visit_alternative()","visit_alternative()","visit_entity()","visit_entity()","visit_entity()","visit_entity()","visit_lookahead()","visit_lookahead()","visit_lookahead()","visit_lookahead()","visit_named()","visit_named()","visit_named()","visit_named()","visit_parser()","visit_parser()","visit_parser()","visit_re()","visit_re()","visit_re()","visit_re()","visit_repetition()","visit_repetition()","visit_repetition()","visit_repetition()","visit_repetition()","visit_sequence()","visit_sequence()","visit_sequence()","visit_sequence()","visit_str()","visit_str()","visit_str()","visit_str()","warn_about_duplicate_keys()","|()","|()","|()","readme"],"longSearchIndex":["object","parslet","parslet::accelerator","parslet::accelerator::application","parslet::accelerator::apply","parslet::accelerator::engine","parslet::accelerator::expression","parslet::atoms","parslet::atoms::alternative","parslet::atoms::base","parslet::atoms::canflatten","parslet::atoms::capture","parslet::atoms::context","parslet::atoms::dsl","parslet::atoms::dynamic","parslet::atoms::entity","parslet::atoms::infix","parslet::atoms::lookahead","parslet::atoms::named","parslet::atoms::precedence","parslet::atoms::re","parslet::atoms::repetition","parslet::atoms::scope","parslet::atoms::sequence","parslet::atoms::str","parslet::cause","parslet::classmethods","parslet::context","parslet::delayedmatchconstructor","parslet::errorreporter","parslet::errorreporter::contextual","parslet::errorreporter::deepest","parslet::errorreporter::tree","parslet::expression","parslet::expression::treetop","parslet::expression::treetop::parser","parslet::expression::treetop::transform","parslet::graphable","parslet::graphvizvisitor","parslet::parsefailed","parslet::parser","parslet::parser::prettyprinter","parslet::parser::visitors","parslet::parser::visitors::citrus","parslet::parser::visitors::treetop","parslet::pattern","parslet::pattern::sequencebind","parslet::pattern::simplebind","parslet::pattern::subtreebind","parslet::position","parslet::scope","parslet::scope::binding","parslet::scope::notfound","parslet::slice","parslet::source","parslet::source::linecache","parslet::source::rangesearch","parslet::transform","rspec","parslet::slice#+()","parslet::position#<=>()","parslet::slice#==()","parslet::accelerator::expression#>>()","parslet::atoms::dsl#>>()","parslet::atoms::sequence#>>()","parslet::delayedmatchconstructor#[]()","parslet::scope#[]()","parslet::scope::binding#[]()","parslet::scope#[]=()","parslet::scope::binding#[]=()","parslet::atoms::infix#abort()","parslet::accelerator::expression#absent?()","parslet::atoms::dsl#absent?()","parslet::atoms::dsl#absnt?()","parslet::atoms::alternative#accept()","parslet::atoms::base#accept()","parslet::atoms::entity#accept()","parslet::atoms::lookahead#accept()","parslet::atoms::named#accept()","parslet::atoms::re#accept()","parslet::atoms::repetition#accept()","parslet::atoms::sequence#accept()","parslet::atoms::str#accept()","parslet::parser#accept()","parslet#any()","parslet::any()","parslet::accelerator#any()","parslet::cause#append_prefix()","parslet::accelerator#apply()","parslet::atoms::base#apply()","parslet::atoms::capture#apply()","parslet::atoms::named#apply()","parslet::atoms::scope#apply()","parslet::transform#apply()","parslet::accelerator::expression#as()","parslet::atoms::dsl#as()","parslet::cause#ascii_tree()","parslet::accelerator::engine#bind()","parslet::pattern::subtreebind#bind_type_name()","parslet::accelerator::engine#bound?()","parslet::source#bytepos()","parslet::source#bytepos=()","parslet::atoms::base#cached?()","parslet::atoms::dynamic#cached?()","parslet::atoms::scope#cached?()","parslet::accelerator::application#call()","parslet::transform#call_on_match()","parslet::pattern::sequencebind#can_bind?()","parslet::pattern::simplebind#can_bind?()","parslet::pattern::subtreebind#can_bind?()","parslet::atoms::dsl#capture()","parslet::atoms::infix#catch_error()","parslet::position#charpos()","parslet::source#chars_left()","parslet::source#chars_until()","parslet::cause#children()","parslet::source#consume()","parslet::errorreporter::deepest#deepest()","parslet::errorreporter::deepest#deepest_child()","parslet::parser::prettyprinter#deferred()","parslet::graphvizvisitor#downwards()","parslet::dynamic()","parslet#dynamic()","parslet::pattern#element_match()","parslet::pattern#element_match_ary_single()","parslet::pattern#element_match_binding()","parslet::pattern#element_match_hash()","parslet::atoms::context#err()","parslet::errorreporter::contextual#err()","parslet::errorreporter::deepest#err()","parslet::errorreporter::tree#err()","parslet::atoms::context#err_at()","parslet::errorreporter::deepest#err_at()","parslet::errorreporter::tree#err_at()","parslet::graphvizvisitor#escape()","parslet::exp()","parslet#exp()","parslet::source::rangesearch#find_mid()","parslet::atoms::canflatten#flatten()","parslet::atoms::canflatten#flatten_repetition()","parslet::atoms::canflatten#flatten_sequence()","parslet::atoms::canflatten#foldl()","parslet::cause::format()","parslet::graphable#graph()","parslet::included()","parslet::infix_expression()","parslet#infix_expression()","parslet::transform::inherited()","parslet::atoms::base#inspect()","parslet::pattern::subtreebind#inspect()","parslet::slice#inspect()","parslet::accelerator::expression#join_or_new()","parslet::source::rangesearch#lbound()","parslet::slice#length()","parslet::slice#line_and_column()","parslet::source#line_and_column()","parslet::source::linecache#line_and_column()","parslet::accelerator::engine#lookup()","parslet::atoms::context#lookup()","parslet::parser::prettyprinter#mangle_name()","parslet::match()","parslet#match()","parslet::accelerator#match()","parslet::accelerator::apply#match()","parslet::accelerator::engine#match()","parslet::pattern#match()","parslet::slice#match()","parslet::source#match()","parslet::atoms::infix#match_operation()","parslet::source#matches?()","parslet::atoms::dsl#maybe()","parslet::atoms::canflatten#merge_fold()","parslet::context#meta_def()","parslet::accelerator::application::new()","parslet::accelerator::apply::new()","parslet::accelerator::engine::new()","parslet::accelerator::expression::new()","parslet::atoms::alternative::new()","parslet::atoms::capture::new()","parslet::atoms::context::new()","parslet::atoms::dynamic::new()","parslet::atoms::entity::new()","parslet::atoms::infix::new()","parslet::atoms::lookahead::new()","parslet::atoms::named::new()","parslet::atoms::re::new()","parslet::atoms::repetition::new()","parslet::atoms::scope::new()","parslet::atoms::sequence::new()","parslet::atoms::str::new()","parslet::cause::new()","parslet::context::new()","parslet::errorreporter::contextual::new()","parslet::errorreporter::deepest::new()","parslet::expression::new()","parslet::graphvizvisitor::new()","parslet::parsefailed::new()","parslet::parser::prettyprinter::new()","parslet::parser::visitors::citrus::new()","parslet::pattern::new()","parslet::position::new()","parslet::scope::new()","parslet::scope::binding::new()","parslet::slice::new()","parslet::source::new()","parslet::source::linecache::new()","parslet::transform::new()","parslet::graphvizvisitor#node()","parslet::slice#offset()","parslet::atoms::base#parse()","parslet::expression#parse()","parslet::atoms::base#parse_with_debug()","parslet::atoms::entity#parslet()","parslet::scope#pop()","parslet::source#pos()","parslet::atoms::base::precedence()","parslet::atoms::infix#precedence_climb()","parslet::accelerator::expression#present?()","parslet::atoms::dsl#present?()","parslet::parser::prettyprinter#pretty_print()","parslet::atoms::named#produce_return_value()","parslet::atoms::infix#produce_tree()","parslet::atoms::dsl#prsnt?()","parslet::scope#push()","parslet::cause#raise()","parslet::atoms::entity#raise_not_implemented()","parslet::accelerator#re()","parslet::graphvizvisitor#recurse()","parslet::transform#recurse_array()","parslet::transform#recurse_hash()","parslet::cause#recursive_ascii_tree()","parslet::accelerator::expression#repeat()","parslet::atoms::dsl#repeat()","parslet::errorreporter::contextual#reset()","parslet::parser::root()","parslet::accelerator#rule()","parslet::classmethods#rule()","parslet::parser::prettyprinter#rule()","parslet::transform#rule()","parslet::transform::rule()","parslet::transform#rules()","parslet::transform::rules()","parslet::source::linecache#scan_for_line_endings()","parslet#scope()","parslet::scope()","parslet::atoms::context#scope()","parslet#sequence()","parslet::sequence()","parslet::atoms::context#set()","parslet::cause#set_label()","parslet::atoms::base#setup_and_apply()","parslet#simple()","parslet::simple()","parslet::slice#size()","parslet::expression::treetop::parser#spaced()","parslet#str()","parslet::str()","parslet::accelerator#str()","parslet::subtree()","parslet#subtree()","parslet::atoms::base#succ()","parslet::atoms::context#succ()","parslet::errorreporter::contextual#succ()","parslet::errorreporter::deepest#succ()","parslet::errorreporter::tree#succ()","parslet::parser#to_citrus()","parslet::slice#to_f()","parslet::slice#to_i()","parslet::slice#to_int()","parslet::expression#to_parslet()","parslet::atoms::base#to_s()","parslet::cause#to_s()","parslet::slice#to_s()","parslet::atoms::alternative#to_s_inner()","parslet::atoms::capture#to_s_inner()","parslet::atoms::dynamic#to_s_inner()","parslet::atoms::entity#to_s_inner()","parslet::atoms::infix#to_s_inner()","parslet::atoms::lookahead#to_s_inner()","parslet::atoms::named#to_s_inner()","parslet::atoms::re#to_s_inner()","parslet::atoms::repetition#to_s_inner()","parslet::atoms::scope#to_s_inner()","parslet::atoms::sequence#to_s_inner()","parslet::atoms::str#to_s_inner()","parslet::parser#to_s_inner()","parslet::slice#to_slice()","parslet::slice#to_str()","parslet::slice#to_sym()","parslet::parser#to_treetop()","parslet::accelerator::application#transform()","parslet::expression#transform()","parslet::transform#transform_elt()","parslet::atoms::alternative#try()","parslet::atoms::base#try()","parslet::atoms::dynamic#try()","parslet::atoms::entity#try()","parslet::atoms::infix#try()","parslet::atoms::lookahead#try()","parslet::atoms::re#try()","parslet::atoms::repetition#try()","parslet::atoms::sequence#try()","parslet::atoms::str#try()","parslet::parser#try()","parslet::accelerator::engine#try_bind()","parslet::atoms::context#try_with_cache()","parslet::atoms::infix#unwrap()","parslet::errorreporter::contextual#update_label()","parslet::pattern::subtreebind#variable_name()","parslet::accelerator::application#visit_alternative()","parslet::accelerator::apply#visit_alternative()","parslet::graphvizvisitor#visit_alternative()","parslet::parser::visitors::citrus#visit_alternative()","parslet::parser::visitors::treetop#visit_alternative()","parslet::accelerator::application#visit_entity()","parslet::accelerator::apply#visit_entity()","parslet::graphvizvisitor#visit_entity()","parslet::parser::visitors::citrus#visit_entity()","parslet::accelerator::application#visit_lookahead()","parslet::accelerator::apply#visit_lookahead()","parslet::graphvizvisitor#visit_lookahead()","parslet::parser::visitors::citrus#visit_lookahead()","parslet::accelerator::application#visit_named()","parslet::accelerator::apply#visit_named()","parslet::graphvizvisitor#visit_named()","parslet::parser::visitors::citrus#visit_named()","parslet::accelerator::application#visit_parser()","parslet::accelerator::apply#visit_parser()","parslet::graphvizvisitor#visit_parser()","parslet::accelerator::application#visit_re()","parslet::accelerator::apply#visit_re()","parslet::graphvizvisitor#visit_re()","parslet::parser::visitors::citrus#visit_re()","parslet::accelerator::application#visit_repetition()","parslet::accelerator::apply#visit_repetition()","parslet::graphvizvisitor#visit_repetition()","parslet::parser::visitors::citrus#visit_repetition()","parslet::parser::visitors::treetop#visit_repetition()","parslet::accelerator::application#visit_sequence()","parslet::accelerator::apply#visit_sequence()","parslet::graphvizvisitor#visit_sequence()","parslet::parser::visitors::citrus#visit_sequence()","parslet::accelerator::application#visit_str()","parslet::accelerator::apply#visit_str()","parslet::graphvizvisitor#visit_str()","parslet::parser::visitors::citrus#visit_str()","parslet::atoms::canflatten#warn_about_duplicate_keys()","parslet::accelerator::expression#|()","parslet::atoms::alternative#|()","parslet::atoms::dsl#|()",""],"info":[["Object","","Object.html","",""],["Parslet","","Parslet.html","","<p>A simple parser generator library. Typical usage would look like this:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;parslet&#39;</span>\n\n<span class=\"ruby-keyword\">class</span> <span class=\"ruby-constant\">MyParser</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["Parslet::Accelerator","","Parslet/Accelerator.html","","<p>Optimizes the parsers by pattern matching on the parser atoms and replacing\nmatches with better versions. …\n"],["Parslet::Accelerator::Application","","Parslet/Accelerator/Application.html","",""],["Parslet::Accelerator::Apply","","Parslet/Accelerator/Apply.html","","<p>@api private\n"],["Parslet::Accelerator::Engine","","Parslet/Accelerator/Engine.html","","<p>@api private\n"],["Parslet::Accelerator::Expression","","Parslet/Accelerator/Expression.html","","<p>An expression to match against a tree of parser atoms. Normally, an\nexpression is produced by Parslet::Accelerator.any …\n"],["Parslet::Atoms","","Parslet/Atoms.html","","<p>This is where parslets name comes from: Small parser atoms.\n"],["Parslet::Atoms::Alternative","","Parslet/Atoms/Alternative.html","","<p>Alternative during matching. Contains a list of parslets that is tried each\none in turn. Only fails if …\n"],["Parslet::Atoms::Base","","Parslet/Atoms/Base.html","","<p>Base class for all parslets, handles orchestration of calls and implements\na lot of the operator and …\n"],["Parslet::Atoms::CanFlatten","","Parslet/Atoms/CanFlatten.html","","<p>A series of helper functions that have the common topic of flattening \nresult values into the intermediary …\n"],["Parslet::Atoms::Capture","","Parslet/Atoms/Capture.html","","<p>Stores the result of matching an atom against input in the #captures in \nparse context. Doing so will …\n"],["Parslet::Atoms::Context","","Parslet/Atoms/Context.html","","<p>Helper class that implements a transient cache that maps position and\nparslet object to results. This …\n"],["Parslet::Atoms::DSL","","Parslet/Atoms/DSL.html","","<p>A mixin module that defines operations that can be called on any subclass\nof Parslet::Atoms::Base. These …\n"],["Parslet::Atoms::Dynamic","","Parslet/Atoms/Dynamic.html","","<p>Evaluates a block at parse time. The result from the block must be a parser\n(something which implements …\n"],["Parslet::Atoms::Entity","","Parslet/Atoms/Entity.html","","<p>This wraps pieces of parslet definition and gives them a name. The wrapped\npiece is lazily evaluated …\n"],["Parslet::Atoms::Infix","","Parslet/Atoms/Infix.html","",""],["Parslet::Atoms::Lookahead","","Parslet/Atoms/Lookahead.html","","<p>Either positive or negative lookahead, doesn&#39;t consume its input.\n<p>Example:\n\n<pre>str(&#39;foo&#39;).present? # ...</pre>\n"],["Parslet::Atoms::Named","","Parslet/Atoms/Named.html","","<p>Names a match to influence tree construction.\n<p>Example:\n\n<pre>str(&#39;foo&#39;)            # will return &#39;foo&#39;, \nstr(&#39;foo&#39;).as(:foo) ...</pre>\n"],["Parslet::Atoms::Precedence","","Parslet/Atoms/Precedence.html","","<p>The precedence module controls parenthesis during the #inspect printing of\nparslets. It is not relevant …\n"],["Parslet::Atoms::Re","","Parslet/Atoms/Re.html","","<p>Matches a special kind of regular expression that only ever matches one\ncharacter at a time. Useful members …\n"],["Parslet::Atoms::Repetition","","Parslet/Atoms/Repetition.html","","<p>Matches a parslet repeatedly.\n<p>Example:\n\n<pre>str(&#39;a&#39;).repeat(1,3)  # matches &#39;a&#39; at least once, but at most ...</pre>\n"],["Parslet::Atoms::Scope","","Parslet/Atoms/Scope.html","","<p>Starts a new scope in the parsing process. Please also see the #captures\nmethod.\n"],["Parslet::Atoms::Sequence","","Parslet/Atoms/Sequence.html","","<p>A sequence of parslets, matched from left to right. Denoted by\n&#39;&gt;&gt;&#39;\n<p>Example:\n\n<pre>str(&#39;a&#39;) &gt;&gt; ...</pre>\n"],["Parslet::Atoms::Str","","Parslet/Atoms/Str.html","","<p>Matches a string of characters.\n<p>Example:\n\n<pre>str(&#39;foo&#39;) # matches &#39;foo&#39;</pre>\n"],["Parslet::Cause","","Parslet/Cause.html","","<p>Represents a cause why a parse did fail. A lot of these objects are\nconstructed - not all of the causes …\n"],["Parslet::ClassMethods","","Parslet/ClassMethods.html","",""],["Parslet::Context","","Parslet/Context.html","","<p>Provides a context for tree transformations to run in. The context allows\naccessing each of the bindings …\n"],["Parslet::DelayedMatchConstructor","","Parslet/DelayedMatchConstructor.html","","<p>Allows for delayed construction of #match. See also Parslet.match.\n<p>@api private\n"],["Parslet::ErrorReporter","","Parslet/ErrorReporter.html","","<p>A namespace for all error reporters.\n"],["Parslet::ErrorReporter::Contextual","","Parslet/ErrorReporter/Contextual.html","","<p>A reporter that tries to improve on the deepest error reporter by using\nheuristics to find the most relevant …\n"],["Parslet::ErrorReporter::Deepest","","Parslet/ErrorReporter/Deepest.html","","<p>Instead of reporting the latest error that happens like {Tree} does, this\nclass reports the deepest error. …\n"],["Parslet::ErrorReporter::Tree","","Parslet/ErrorReporter/Tree.html","","<p>An error reporter has two central methods, one for reporting errors at the\ncurrent parse position (#err) …\n"],["Parslet::Expression","","Parslet/Expression.html","","<p>Allows specifying rules as strings using the exact same grammar that\ntreetop does, minus the actions. …\n"],["Parslet::Expression::Treetop","","Parslet/Expression/Treetop.html","",""],["Parslet::Expression::Treetop::Parser","","Parslet/Expression/Treetop/Parser.html","",""],["Parslet::Expression::Treetop::Transform","","Parslet/Expression/Treetop/Transform.html","",""],["Parslet::Graphable","","Parslet/Graphable.html","",""],["Parslet::GraphvizVisitor","","Parslet/GraphvizVisitor.html","",""],["Parslet::ParseFailed","","Parslet/ParseFailed.html","","<p>Raised when the parse failed to match. It contains the message that should\nbe presented to the user. …\n"],["Parslet::Parser","","Parslet/Parser.html","","<p>The base class for all your parsers. Use as follows:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;parslet&#39;</span>\n\n<span class=\"ruby-keyword\">class</span> <span class=\"ruby-constant\">MyParser</span> <span class=\"ruby-operator\">&lt;</span> <span class=\"ruby-constant\">Parslet</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Parser</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["Parslet::Parser::PrettyPrinter","","Parslet/Parser/PrettyPrinter.html","","<p>A helper class that formats Citrus and Treetop grammars as a string.\n"],["Parslet::Parser::Visitors","","Parslet/Parser/Visitors.html","",""],["Parslet::Parser::Visitors::Citrus","","Parslet/Parser/Visitors/Citrus.html","",""],["Parslet::Parser::Visitors::Treetop","","Parslet/Parser/Visitors/Treetop.html","",""],["Parslet::Pattern","","Parslet/Pattern.html","","<p>Matches trees against expressions. Trees are formed by arrays and hashes\nfor expressing membership and …\n"],["Parslet::Pattern::SequenceBind","","Parslet/Pattern/SequenceBind.html","","<p>Binds a symbol to a sequence of simple leafs ([element1, element2, …])\n"],["Parslet::Pattern::SimpleBind","","Parslet/Pattern/SimpleBind.html","","<p>Binds a symbol to a simple subtree, one that is not either a sequence of\nelements or a collection of …\n"],["Parslet::Pattern::SubtreeBind","","Parslet/Pattern/SubtreeBind.html","","<p>Used internally for representing a bind placeholder in a Parslet::Transform\npattern. This is the superclass …\n"],["Parslet::Position","","Parslet/Position.html","","<p>Encapsules the concept of a position inside a string.\n"],["Parslet::Scope","","Parslet/Scope.html","",""],["Parslet::Scope::Binding","","Parslet/Scope/Binding.html","",""],["Parslet::Scope::NotFound","","Parslet/Scope/NotFound.html","","<p>Raised when the accessed slot has never been assigned a value.\n"],["Parslet::Slice","","Parslet/Slice.html","","<p>A slice is a small part from the parse input. A slice mainly behaves like\nany other string, except that …\n"],["Parslet::Source","","Parslet/Source.html","","<p>Wraps the input string for parslet.\n"],["Parslet::Source::LineCache","","Parslet/Source/LineCache.html","","<p>A cache for line start positions.\n"],["Parslet::Source::RangeSearch","","Parslet/Source/RangeSearch.html","","<p>Mixin for arrays that implicitly give a number of ranges, where one range\nbegins where the other one …\n"],["Parslet::Transform","","Parslet/Transform.html","","<p>Transforms an expression tree into something else. The transformation\nperforms a depth-first, post-order …\n"],["RSpec","","RSpec.html","",""],["+","Parslet::Slice","Parslet/Slice.html#method-i-2B","(other)","<p>Concatenate two slices; it is assumed that the second slice begins  where\nthe first one ends. The offset …\n"],["<=>","Parslet::Position","Parslet/Position.html#method-i-3C-3D-3E","(b)",""],["==","Parslet::Slice","Parslet/Slice.html#method-i-3D-3D","(other)","<p>Compares slices to other slices or strings.\n"],[">>","Parslet::Accelerator::Expression","Parslet/Accelerator/Expression.html#method-i-3E-3E","(other_expr)","<p>@return [Expression]\n"],[">>","Parslet::Atoms::DSL","Parslet/Atoms/DSL.html#method-i-3E-3E","(parslet)","<p>Chains two parslet atoms together as a sequence.\n<p>Example:\n\n<pre>str(&#39;a&#39;) &gt;&gt; str(&#39;b&#39;)</pre>\n"],[">>","Parslet::Atoms::Sequence","Parslet/Atoms/Sequence.html#method-i-3E-3E","(parslet)",""],["[]","Parslet::DelayedMatchConstructor","Parslet/DelayedMatchConstructor.html#method-i-5B-5D","(str)",""],["[]","Parslet::Scope","Parslet/Scope.html#method-i-5B-5D","(k)",""],["[]","Parslet::Scope::Binding","Parslet/Scope/Binding.html#method-i-5B-5D","(k)",""],["[]=","Parslet::Scope","Parslet/Scope.html#method-i-5B-5D-3D","(k,v)",""],["[]=","Parslet::Scope::Binding","Parslet/Scope/Binding.html#method-i-5B-5D-3D","(k,v)",""],["abort","Parslet::Atoms::Infix","Parslet/Atoms/Infix.html#method-i-abort","(error)",""],["absent?","Parslet::Accelerator::Expression","Parslet/Accelerator/Expression.html#method-i-absent-3F","()","<p>@return [Expression]\n"],["absent?","Parslet::Atoms::DSL","Parslet/Atoms/DSL.html#method-i-absent-3F","()","<p>Tests for absence of a parslet atom in the input stream without consuming\nit.\n<p>Example:\n\n<pre># Only proceed ...</pre>\n"],["absnt?","Parslet::Atoms::DSL","Parslet/Atoms/DSL.html#method-i-absnt-3F","()","<p>Alias for absent? that will disappear in 2.0 (deprecated)\n"],["accept","Parslet::Atoms::Alternative","Parslet/Atoms/Alternative.html#method-i-accept","(visitor)","<p>Call back visitors #visit_alternative method. See parslet/export for an\nexample.\n"],["accept","Parslet::Atoms::Base","Parslet/Atoms/Base.html#method-i-accept","(visitor)",""],["accept","Parslet::Atoms::Entity","Parslet/Atoms/Entity.html#method-i-accept","(visitor)","<p>Call back visitors #visit_entity method. See parslet/export for an example.\n"],["accept","Parslet::Atoms::Lookahead","Parslet/Atoms/Lookahead.html#method-i-accept","(visitor)","<p>Call back visitors #visit_lookahead method. See parslet/export for an\nexample.\n"],["accept","Parslet::Atoms::Named","Parslet/Atoms/Named.html#method-i-accept","(visitor)","<p>Call back visitors #visit_named method. See parslet/export for an example.\n"],["accept","Parslet::Atoms::Re","Parslet/Atoms/Re.html#method-i-accept","(visitor)","<p>Call back visitors #visit_re method. See parslet/export for an example.\n"],["accept","Parslet::Atoms::Repetition","Parslet/Atoms/Repetition.html#method-i-accept","(visitor)","<p>Call back visitors #visit_repetition method. See parslet/export for an\nexample.\n"],["accept","Parslet::Atoms::Sequence","Parslet/Atoms/Sequence.html#method-i-accept","(visitor)","<p>Call back visitors #visit_sequence method. See parslet/export for an\nexample.\n"],["accept","Parslet::Atoms::Str","Parslet/Atoms/Str.html#method-i-accept","(visitor)","<p>Call back visitors #visit_str method. See parslet/export for an example.\n"],["accept","Parslet::Parser","Parslet/Parser.html#method-i-accept","(visitor)","<p>Call back visitors #visit_parser method.\n"],["any","Parslet","Parslet.html#method-i-any","()","<p>Returns an atom matching any character. It acts like the &#39;.&#39; (dot)\ncharacter in regular expressions. …\n"],["any","Parslet","Parslet.html#method-c-any","()","<p>Returns an atom matching any character. It acts like the &#39;.&#39; (dot)\ncharacter in regular expressions. …\n"],["any","Parslet::Accelerator","Parslet/Accelerator.html#method-i-any","()","<p>Returns a match expression that will match `any` parslet atoms.\n<p>@return [Parslet::Accelerator::Expression] …\n"],["append_prefix","Parslet::Cause","Parslet/Cause.html#method-i-append_prefix","(stream, curved)",""],["apply","Parslet::Accelerator","Parslet/Accelerator.html#method-i-apply","(atom, *rules)","<p>Given a parslet atom and a set of rules, tries to match the rules \nrecursively through the parslet atom. …\n"],["apply","Parslet::Atoms::Base","Parslet/Atoms/Base.html#method-i-apply","(source, context, consume_all=false)","\n<pre>Calls the #try method of this parslet. Success consumes input, error will \nrewind the input. \n\n@param ...</pre>\n"],["apply","Parslet::Atoms::Capture","Parslet/Atoms/Capture.html#method-i-apply","(source, context, consume_all)",""],["apply","Parslet::Atoms::Named","Parslet/Atoms/Named.html#method-i-apply","(source, context, consume_all)",""],["apply","Parslet::Atoms::Scope","Parslet/Atoms/Scope.html#method-i-apply","(source, context, consume_all)",""],["apply","Parslet::Transform","Parslet/Transform.html#method-i-apply","(obj, context=nil)","<p>Applies the transformation to a tree that is generated by Parslet::Parser\nor a simple parslet. Transformation …\n"],["as","Parslet::Accelerator::Expression","Parslet/Accelerator/Expression.html#method-i-as","(name)","<p>@return [Expression]\n"],["as","Parslet::Atoms::DSL","Parslet/Atoms/DSL.html#method-i-as","(name)","<p>Marks a parslet atom as important for the tree output. This must be used \nto achieve meaningful output …\n"],["ascii_tree","Parslet::Cause","Parslet/Cause.html#method-i-ascii_tree","()","<p>Returns an ascii tree representation of the causes of this node and its\nchildren.\n"],["bind","Parslet::Accelerator::Engine","Parslet/Accelerator/Engine.html#method-i-bind","(var, val)",""],["bind_type_name","Parslet::Pattern::SubtreeBind","Parslet/Pattern/SubtreeBind.html#method-i-bind_type_name","()",""],["bound?","Parslet::Accelerator::Engine","Parslet/Accelerator/Engine.html#method-i-bound-3F","(var)",""],["bytepos","Parslet::Source","Parslet/Source.html#method-i-bytepos","()",""],["bytepos=","Parslet::Source","Parslet/Source.html#method-i-bytepos-3D","(n)","<p>@note Please be aware of encodings at this point.\n"],["cached?","Parslet::Atoms::Base","Parslet/Atoms/Base.html#method-i-cached-3F","()","<p>Returns true if this atom can be cached in the packrat cache. Most parslet\natoms are cached, so this …\n"],["cached?","Parslet::Atoms::Dynamic","Parslet/Atoms/Dynamic.html#method-i-cached-3F","()",""],["cached?","Parslet::Atoms::Scope","Parslet/Atoms/Scope.html#method-i-cached-3F","()",""],["call","Parslet::Accelerator::Application","Parslet/Accelerator/Application.html#method-i-call","()",""],["call_on_match","Parslet::Transform","Parslet/Transform.html#method-i-call_on_match","(bindings, block)","<p>Executes the block on the bindings obtained by Pattern#match, if such a\nmatch can be made. Depending …\n"],["can_bind?","Parslet::Pattern::SequenceBind","Parslet/Pattern/SequenceBind.html#method-i-can_bind-3F","(subtree)",""],["can_bind?","Parslet::Pattern::SimpleBind","Parslet/Pattern/SimpleBind.html#method-i-can_bind-3F","(subtree)",""],["can_bind?","Parslet::Pattern::SubtreeBind","Parslet/Pattern/SubtreeBind.html#method-i-can_bind-3F","(subtree)",""],["capture","Parslet::Atoms::DSL","Parslet/Atoms/DSL.html#method-i-capture","(name)","<p>Captures a part of the input and stores it under the name given. This  is\nvery useful to create self-referential …\n"],["catch_error","Parslet::Atoms::Infix","Parslet/Atoms/Infix.html#method-i-catch_error","()",""],["charpos","Parslet::Position","Parslet/Position.html#method-i-charpos","()",""],["chars_left","Parslet::Source","Parslet/Source.html#method-i-chars_left","()","<p>Returns how many chars remain in the input.\n"],["chars_until","Parslet::Source","Parslet/Source.html#method-i-chars_until","(str)","<p>Returns how many chars there are between current position and the  string\ngiven. If the string given …\n"],["children","Parslet::Cause","Parslet/Cause.html#method-i-children","()","<p>When this cause is part of a tree of error causes: child nodes for this\nnode. Very often carries the …\n"],["consume","Parslet::Source","Parslet/Source.html#method-i-consume","(n)","<p>Consumes n characters from the input, returning them as a slice of the\ninput.\n"],["deepest","Parslet::ErrorReporter::Deepest","Parslet/ErrorReporter/Deepest.html#method-i-deepest","(cause)","<p>Checks to see if the lineage of the cause given includes a cause with an\nerror position deeper than the …\n"],["deepest_child","Parslet::ErrorReporter::Deepest","Parslet/ErrorReporter/Deepest.html#method-i-deepest_child","(cause, rank=0)","<p>Returns the leaf from a given error tree with the biggest rank.\n"],["deferred","Parslet::Parser::PrettyPrinter","Parslet/Parser/PrettyPrinter.html#method-i-deferred","(name, content)","<p>Whenever the visitor encounters an rule in a parslet, it defers the pretty\nprinting of the rule by calling …\n"],["downwards","Parslet::GraphvizVisitor","Parslet/GraphvizVisitor.html#method-i-downwards","(child)",""],["dynamic","Parslet","Parslet.html#method-c-dynamic","(&block)","<p>Designates a piece of the parser as being dynamic. Dynamic parsers can\neither return a parser at runtime, …\n"],["dynamic","Parslet","Parslet.html#method-i-dynamic","(&block)","<p>Designates a piece of the parser as being dynamic. Dynamic parsers can\neither return a parser at runtime, …\n"],["element_match","Parslet::Pattern","Parslet/Pattern.html#method-i-element_match","(tree, exp, bindings)","<p>Returns true if the tree element given by <code>tree</code> matches the\nexpression given by <code>exp</code>. This match must respect …\n"],["element_match_ary_single","Parslet::Pattern","Parslet/Pattern.html#method-i-element_match_ary_single","(sequence, exp, bindings)","<p>@api private\n"],["element_match_binding","Parslet::Pattern","Parslet/Pattern.html#method-i-element_match_binding","(tree, exp, bindings)","<p>@api private\n"],["element_match_hash","Parslet::Pattern","Parslet/Pattern.html#method-i-element_match_hash","(tree, exp, bindings)","<p>@api private\n"],["err","Parslet::Atoms::Context","Parslet/Atoms/Context.html#method-i-err","(*args)","<p>Report an error.  @see ErrorReporter\n"],["err","Parslet::ErrorReporter::Contextual","Parslet/ErrorReporter/Contextual.html#method-i-err","(atom, source, message, children=nil)","<p>Produces an error cause that combines the message at the current level with\nthe errors that happened …\n"],["err","Parslet::ErrorReporter::Deepest","Parslet/ErrorReporter/Deepest.html#method-i-err","(atom, source, message, children=nil)","<p>Produces an error cause that combines the message at the current level with\nthe errors that happened …\n"],["err","Parslet::ErrorReporter::Tree","Parslet/ErrorReporter/Tree.html#method-i-err","(atom, source, message, children=nil)","<p>Produces an error cause that combines the message at the current level with\nthe errors that happened …\n"],["err_at","Parslet::Atoms::Context","Parslet/Atoms/Context.html#method-i-err_at","(*args)","<p>Report an error at a given position.  @see ErrorReporter\n"],["err_at","Parslet::ErrorReporter::Deepest","Parslet/ErrorReporter/Deepest.html#method-i-err_at","(atom, source, message, pos, children=nil)","<p>Produces an error cause that combines the message at the current level with\nthe errors that happened …\n"],["err_at","Parslet::ErrorReporter::Tree","Parslet/ErrorReporter/Tree.html#method-i-err_at","(atom, source, message, pos, children=nil)","<p>Produces an error cause that combines the message at the current level with\nthe errors that happened …\n"],["escape","Parslet::GraphvizVisitor","Parslet/GraphvizVisitor.html#method-i-escape","(str)",""],["exp","Parslet","Parslet.html#method-c-exp","(str)","<p>A special kind of atom that allows embedding whole treetop expressions into\nparslet construction.\n\n<pre># the ...</pre>\n"],["exp","Parslet","Parslet.html#method-i-exp","(str)","<p>A special kind of atom that allows embedding whole treetop expressions into\nparslet construction.\n\n<pre># the ...</pre>\n"],["find_mid","Parslet::Source::RangeSearch","Parslet/Source/RangeSearch.html#method-i-find_mid","(left, right)",""],["flatten","Parslet::Atoms::CanFlatten","Parslet/Atoms/CanFlatten.html#method-i-flatten","(value, named=false)","<p>Takes a mixed value coming out of a parslet and converts it to a return\nvalue for the user by dropping …\n"],["flatten_repetition","Parslet::Atoms::CanFlatten","Parslet/Atoms/CanFlatten.html#method-i-flatten_repetition","(list, named)","<p>Flatten results from a repetition of a single parslet. named indicates\nwhether the user has named the …\n"],["flatten_sequence","Parslet::Atoms::CanFlatten","Parslet/Atoms/CanFlatten.html#method-i-flatten_sequence","(list)","<p>Flatten results from a sequence of parslets.\n<p>@api private\n"],["foldl","Parslet::Atoms::CanFlatten","Parslet/Atoms/CanFlatten.html#method-i-foldl","(list, &block)","<p>Lisp style fold left where the first element builds the basis for  an\ninject.\n"],["format","Parslet::Cause","Parslet/Cause.html#method-c-format","(source, pos, str, children=[])","<p>Appends &#39;at line LINE char CHAR&#39; to the string given. Use\n<code>pos</code> to override the position of the …\n"],["graph","Parslet::Graphable","Parslet/Graphable.html#method-i-graph","(opts)",""],["included","Parslet","Parslet.html#method-c-included","(base)","<p>Extends classes that include Parslet with the module\n{Parslet::ClassMethods}.\n"],["infix_expression","Parslet","Parslet.html#method-c-infix_expression","(element, *operations)","<p>Returns a parslet atom that parses infix expressions. Operations are \nspecified as a list of &lt;atom, …\n"],["infix_expression","Parslet","Parslet.html#method-i-infix_expression","(element, *operations)","<p>Returns a parslet atom that parses infix expressions. Operations are \nspecified as a list of &lt;atom, …\n"],["inherited","Parslet::Transform","Parslet/Transform.html#method-c-inherited","(subclass)",""],["inspect","Parslet::Atoms::Base","Parslet/Atoms/Base.html#method-i-inspect","()",""],["inspect","Parslet::Pattern::SubtreeBind","Parslet/Pattern/SubtreeBind.html#method-i-inspect","()",""],["inspect","Parslet::Slice","Parslet/Slice.html#method-i-inspect","()","<p>Prints the slice as <code>&quot;string&quot;@offset</code>.\n"],["join_or_new","Parslet::Accelerator::Expression","Parslet/Accelerator/Expression.html#method-i-join_or_new","(tag, other_expr)","<p>@api private @return [Expression]\n"],["lbound","Parslet::Source::RangeSearch","Parslet/Source/RangeSearch.html#method-i-lbound","(bound)","<p>Scans the array for the first number that is &gt; than bound. Returns the \nindex of that number.\n"],["length","Parslet::Slice","Parslet/Slice.html#method-i-length","()",""],["line_and_column","Parslet::Slice","Parslet/Slice.html#method-i-line_and_column","()","<p>Returns a &lt;line, column&gt; tuple referring to the original input.\n"],["line_and_column","Parslet::Source","Parslet/Source.html#method-i-line_and_column","(position=nil)","<p>Returns a &lt;line, column&gt; tuple for the given position. If no position\nis given, line/column information …\n"],["line_and_column","Parslet::Source::LineCache","Parslet/Source/LineCache.html#method-i-line_and_column","(pos)","<p>Returns a &lt;line, column&gt; tuple for the given input position. Input\nposition must be given as byte …\n"],["lookup","Parslet::Accelerator::Engine","Parslet/Accelerator/Engine.html#method-i-lookup","(var)",""],["lookup","Parslet::Atoms::Context","Parslet/Atoms/Context.html#method-i-lookup","(obj, pos)","<p>NOTE These methods use #object_id directly, since that seems to bring the\nmost performance benefit.  …\n"],["mangle_name","Parslet::Parser::PrettyPrinter","Parslet/Parser/PrettyPrinter.html#method-i-mangle_name","(str)","<p>Mangles names so that Citrus and Treetop can live with it. This mostly\ntransforms some of the things …\n"],["match","Parslet","Parslet.html#method-c-match","(str=nil)","<p>Returns an atom matching a character class. All regular expressions can be\nused, as long as they match …\n"],["match","Parslet","Parslet.html#method-i-match","(str=nil)","<p>Returns an atom matching a character class. All regular expressions can be\nused, as long as they match …\n"],["match","Parslet::Accelerator","Parslet/Accelerator.html#method-i-match","(atom, expr)","<p>Given a parslet atom and an expression, will determine if the expression\nmatches the atom. If successful, …\n"],["match","Parslet::Accelerator::Apply","Parslet/Accelerator/Apply.html#method-i-match","(type_tag)",""],["match","Parslet::Accelerator::Engine","Parslet/Accelerator/Engine.html#method-i-match","(atom, expr)",""],["match","Parslet::Pattern","Parslet/Pattern.html#method-i-match","(subtree, bindings=nil)","<p>Decides if the given subtree matches this pattern. Returns the bindings\nmade on a successful match or …\n"],["match","Parslet::Slice","Parslet/Slice.html#method-i-match","(regexp)","<p>Match regular expressions.\n"],["match","Parslet::Source","Parslet/Source.html#method-i-match","(pattern)",""],["match_operation","Parslet::Atoms::Infix","Parslet/Atoms/Infix.html#method-i-match_operation","(source, context, consume_all)",""],["matches?","Parslet::Source","Parslet/Source.html#method-i-matches-3F","(pattern)","<p>Checks if the given pattern matches at the current input position.\n<p>@param pattern [Regexp] pattern to …\n"],["maybe","Parslet::Atoms::DSL","Parslet/Atoms/DSL.html#method-i-maybe","()","<p>Returns a new parslet atom that is only maybe present in the input. This is\nsynonymous to calling #repeat …\n"],["merge_fold","Parslet::Atoms::CanFlatten","Parslet/Atoms/CanFlatten.html#method-i-merge_fold","(l, r)","<p>@api private\n"],["meta_def","Parslet::Context","Parslet/Context.html#method-i-meta_def","(name, &body)",""],["new","Parslet::Accelerator::Application","Parslet/Accelerator/Application.html#method-c-new","(atom, rules)",""],["new","Parslet::Accelerator::Apply","Parslet/Accelerator/Apply.html#method-c-new","(engine, expr)",""],["new","Parslet::Accelerator::Engine","Parslet/Accelerator/Engine.html#method-c-new","()",""],["new","Parslet::Accelerator::Expression","Parslet/Accelerator/Expression.html#method-c-new","(type, *args)",""],["new","Parslet::Atoms::Alternative","Parslet/Atoms/Alternative.html#method-c-new","(*alternatives)","<p>Constructs an Alternative instance using all given parslets in the order\ngiven. This is what happens …\n"],["new","Parslet::Atoms::Capture","Parslet/Atoms/Capture.html#method-c-new","(parslet, name)",""],["new","Parslet::Atoms::Context","Parslet/Atoms/Context.html#method-c-new","(reporter=Parslet::ErrorReporter::Tree.new)","<p>@param reporter [#err, #err_at] Error reporter (leave empty for default\n\n<pre>reporter)</pre>\n"],["new","Parslet::Atoms::Dynamic","Parslet/Atoms/Dynamic.html#method-c-new","(block)",""],["new","Parslet::Atoms::Entity","Parslet/Atoms/Entity.html#method-c-new","(name, label=nil, &block)",""],["new","Parslet::Atoms::Infix","Parslet/Atoms/Infix.html#method-c-new","(element, operations)",""],["new","Parslet::Atoms::Lookahead","Parslet/Atoms/Lookahead.html#method-c-new","(bound_parslet, positive=true)",""],["new","Parslet::Atoms::Named","Parslet/Atoms/Named.html#method-c-new","(parslet, name)",""],["new","Parslet::Atoms::Re","Parslet/Atoms/Re.html#method-c-new","(match)",""],["new","Parslet::Atoms::Repetition","Parslet/Atoms/Repetition.html#method-c-new","(parslet, min, max, tag=:repetition)",""],["new","Parslet::Atoms::Scope","Parslet/Atoms/Scope.html#method-c-new","(block)",""],["new","Parslet::Atoms::Sequence","Parslet/Atoms/Sequence.html#method-c-new","(*parslets)",""],["new","Parslet::Atoms::Str","Parslet/Atoms/Str.html#method-c-new","(str)",""],["new","Parslet::Cause","Parslet/Cause.html#method-c-new","(message, source, pos, children)",""],["new","Parslet::Context","Parslet/Context.html#method-c-new","(bindings)",""],["new","Parslet::ErrorReporter::Contextual","Parslet/ErrorReporter/Contextual.html#method-c-new","()",""],["new","Parslet::ErrorReporter::Deepest","Parslet/ErrorReporter/Deepest.html#method-c-new","()",""],["new","Parslet::Expression","Parslet/Expression.html#method-c-new","(str, opts={}, context=self)","<p>Creates a parslet from a foreign language expression.\n<p>Example:\n\n<pre>Parslet::Expression.new(&quot;&#39;a&#39; &#39;b&#39;&quot;)</pre>\n"],["new","Parslet::GraphvizVisitor","Parslet/GraphvizVisitor.html#method-c-new","(g)",""],["new","Parslet::ParseFailed","Parslet/ParseFailed.html#method-c-new","(message, cause=nil)",""],["new","Parslet::Parser::PrettyPrinter","Parslet/Parser/PrettyPrinter.html#method-c-new","(visitor_klass)",""],["new","Parslet::Parser::Visitors::Citrus","Parslet/Parser/Visitors/Citrus.html#method-c-new","(context)",""],["new","Parslet::Pattern","Parslet/Pattern.html#method-c-new","(pattern)",""],["new","Parslet::Position","Parslet/Position.html#method-c-new","(string, bytepos)",""],["new","Parslet::Scope","Parslet/Scope.html#method-c-new","()",""],["new","Parslet::Scope::Binding","Parslet/Scope/Binding.html#method-c-new","(parent=nil)",""],["new","Parslet::Slice","Parslet/Slice.html#method-c-new","(position, string, line_cache=nil)","<p>Construct a slice using a string, an offset and an optional line cache. \nThe line cache should be able …\n"],["new","Parslet::Source","Parslet/Source.html#method-c-new","(str)",""],["new","Parslet::Source::LineCache","Parslet/Source/LineCache.html#method-c-new","()",""],["new","Parslet::Transform","Parslet/Transform.html#method-c-new","(&block)",""],["node","Parslet::GraphvizVisitor","Parslet/GraphvizVisitor.html#method-i-node","(name, opts={})",""],["offset","Parslet::Slice","Parslet/Slice.html#method-i-offset","()",""],["parse","Parslet::Atoms::Base","Parslet/Atoms/Base.html#method-i-parse","(io, options={})","<p>Given a string or an IO object, this will attempt a parse of its contents\nand return a result. If the …\n"],["parse","Parslet::Expression","Parslet/Expression.html#method-i-parse","(str)","<p>Parses the string and returns a parse tree.\n"],["parse_with_debug","Parslet::Atoms::Base","Parslet/Atoms/Base.html#method-i-parse_with_debug","(str, opts={})","<p>Packages the common idiom\n\n<pre class=\"ruby\"><span class=\"ruby-keyword\">begin</span>\n  <span class=\"ruby-identifier\">tree</span> = <span class=\"ruby-identifier\">parser</span>.<span class=\"ruby-identifier\">parse</span>(<span class=\"ruby-string\">&#39;something&#39;</span>)\n<span class=\"ruby-keyword\">rescue</span> <span class=\"ruby-constant\">Parslet</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">ParseFailed</span> =<span class=\"ruby-operator\">&gt;</span> <span class=\"ruby-identifier\">error</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["parslet","Parslet::Atoms::Entity","Parslet/Atoms/Entity.html#method-i-parslet","()",""],["pop","Parslet::Scope","Parslet/Scope.html#method-i-pop","()",""],["pos","Parslet::Source","Parslet/Source.html#method-i-pos","()","<p>Position of the parse as a character offset into the original string.\n<p>@note Please be aware of encodings …\n"],["precedence","Parslet::Atoms::Base","Parslet/Atoms/Base.html#method-c-precedence","(prec)","<p>Debug printing - in Treetop syntax.\n"],["precedence_climb","Parslet::Atoms::Infix","Parslet/Atoms/Infix.html#method-i-precedence_climb","(source, context, consume_all, current_prec=1, needs_element=false)","<p>A precedence climbing algorithm married to parslet, as described here\n\n<pre>http://eli.thegreenplace.net/2012/08/02/parsing-expressions-by-precedence-climbing/</pre>\n"],["present?","Parslet::Accelerator::Expression","Parslet/Accelerator/Expression.html#method-i-present-3F","()","<p>@return [Expression]\n"],["present?","Parslet::Atoms::DSL","Parslet/Atoms/DSL.html#method-i-present-3F","()","<p>Tests for presence of a parslet atom in the input stream without consuming\nit.\n<p>Example:\n\n<pre># Only proceed ...</pre>\n"],["pretty_print","Parslet::Parser::PrettyPrinter","Parslet/Parser/PrettyPrinter.html#method-i-pretty_print","(name, parslet)","<p>Pretty prints the given parslet using the visitor that has been configured\nin initialize. Returns the …\n"],["produce_return_value","Parslet::Atoms::Named","Parslet/Atoms/Named.html#method-i-produce_return_value","(val)",""],["produce_tree","Parslet::Atoms::Infix","Parslet/Atoms/Infix.html#method-i-produce_tree","(ary)","<p>Turns an array of the form [&#39;1&#39;, &#39;+&#39;, [&#39;2&#39;,\n&#39;*&#39;, &#39;3&#39;]] into a …\n"],["prsnt?","Parslet::Atoms::DSL","Parslet/Atoms/DSL.html#method-i-prsnt-3F","()","<p>Alias for present? that will disappear in 2.0 (deprecated)\n"],["push","Parslet::Scope","Parslet/Scope.html#method-i-push","()",""],["raise","Parslet::Cause","Parslet/Cause.html#method-i-raise","(exception_klass=Parslet::ParseFailed)","<p>Signals to the outside that the parse has failed. Use this in conjunction\nwith .format for nice error …\n"],["raise_not_implemented","Parslet::Atoms::Entity","Parslet/Atoms/Entity.html#method-i-raise_not_implemented","()",""],["re","Parslet::Accelerator","Parslet/Accelerator.html#method-i-re","(variable, *constraints)","<p>Returns a match expression that will match `match` parslet atoms.\n<p>@return [Parslet::Accelerator::Expression] …\n"],["recurse","Parslet::GraphvizVisitor","Parslet/GraphvizVisitor.html#method-i-recurse","(node, current)",""],["recurse_array","Parslet::Transform","Parslet/Transform.html#method-i-recurse_array","(ary, ctx)","<p>@api private\n"],["recurse_hash","Parslet::Transform","Parslet/Transform.html#method-i-recurse_hash","(hsh, ctx)","<p>@api private\n"],["recursive_ascii_tree","Parslet::Cause","Parslet/Cause.html#method-i-recursive_ascii_tree","(node, stream, curved)",""],["repeat","Parslet::Accelerator::Expression","Parslet/Accelerator/Expression.html#method-i-repeat","(min=0, max=nil)","<p>@return [Expression]\n"],["repeat","Parslet::Atoms::DSL","Parslet/Atoms/DSL.html#method-i-repeat","(min=0, max=nil)","<p>Construct a new atom that repeats the current atom min times at least and\nat most max times. max can …\n"],["reset","Parslet::ErrorReporter::Contextual","Parslet/ErrorReporter/Contextual.html#method-i-reset","()","<p>Reset deepest error and its position and sequence index\n"],["root","Parslet::Parser","Parslet/Parser.html#method-c-root","(name)","<p>Define the parsers #root function. This is the place where you start \nparsing; if you have a rule for …\n"],["rule","Parslet::Accelerator","Parslet/Accelerator.html#method-i-rule","(expression, &action)","<p>Constructs an accelerator rule. A rule is a matching expression and the\ncode that should be executed …\n"],["rule","Parslet::ClassMethods","Parslet/ClassMethods.html#method-i-rule","(name, opts={}, &definition)","<p>Define an entity for the parser. This generates a method of the same name\nthat can be used as part of …\n"],["rule","Parslet::Parser::PrettyPrinter","Parslet/Parser/PrettyPrinter.html#method-i-rule","(name, parslet)","<p>Formats a rule in either dialect.\n"],["rule","Parslet::Transform","Parslet/Transform.html#method-i-rule","(expression, &block)","<p>Defines a rule to be applied whenever apply is called on a tree. A rule is\ncomposed of two parts:\n<p>an …\n"],["rule","Parslet::Transform","Parslet/Transform.html#method-c-rule","(expression, &block)","<p>Define a rule for the transform subclass.\n"],["rules","Parslet::Transform","Parslet/Transform.html#method-i-rules","()","<p>Allow easy access to all rules, the ones defined in the instance and the \nones predefined in a subclass …\n"],["rules","Parslet::Transform","Parslet/Transform.html#method-c-rules","()","<p>Allows accessing the class&#39; rules\n"],["scan_for_line_endings","Parslet::Source::LineCache","Parslet/Source/LineCache.html#method-i-scan_for_line_endings","(start_pos, buf)",""],["scope","Parslet","Parslet.html#method-i-scope","(&block)","<p>Introduces a new capture scope. This means that all old captures stay\naccessible, but new values stored …\n"],["scope","Parslet","Parslet.html#method-c-scope","(&block)","<p>Introduces a new capture scope. This means that all old captures stay\naccessible, but new values stored …\n"],["scope","Parslet::Atoms::Context","Parslet/Atoms/Context.html#method-i-scope","()","<p>Starts a new scope. Use the #scope method of Parslet::Atoms::DSL to call\nthis.\n"],["sequence","Parslet","Parslet.html#method-i-sequence","(symbol)","<p>Returns a placeholder for a tree transformation that will only match a\nsequence of elements. The <code>symbol</code> …\n"],["sequence","Parslet","Parslet.html#method-c-sequence","(symbol)","<p>Returns a placeholder for a tree transformation that will only match a\nsequence of elements. The <code>symbol</code> …\n"],["set","Parslet::Atoms::Context","Parslet/Atoms/Context.html#method-i-set","(obj, pos, val)",""],["set_label","Parslet::Cause","Parslet/Cause.html#method-i-set_label","(l)","<p>Update error message to include context provided by label Update all child\ncauses too (the same context …\n"],["setup_and_apply","Parslet::Atoms::Base","Parslet/Atoms/Base.html#method-i-setup_and_apply","(source, error_reporter, consume_all)","<p>Creates a context for parsing and applies the current atom to the input. \nReturns the parse result.  …\n"],["simple","Parslet","Parslet.html#method-i-simple","(symbol)","<p>Returns a placeholder for a tree transformation that will only match simple\nelements. This matches everything …\n"],["simple","Parslet","Parslet.html#method-c-simple","(symbol)","<p>Returns a placeholder for a tree transformation that will only match simple\nelements. This matches everything …\n"],["size","Parslet::Slice","Parslet/Slice.html#method-i-size","()","<p>Returns the slices size in characters.\n"],["spaced","Parslet::Expression::Treetop::Parser","Parslet/Expression/Treetop/Parser.html#method-i-spaced","(str)",""],["str","Parslet","Parslet.html#method-i-str","(str)","<p>Returns an atom matching the <code>str</code> given:\n\n<pre>str(&#39;class&#39;)      # will match &#39;class&#39;</pre>\n<p>@param str [String] string …\n"],["str","Parslet","Parslet.html#method-c-str","(str)","<p>Returns an atom matching the <code>str</code> given:\n\n<pre>str(&#39;class&#39;)      # will match &#39;class&#39;</pre>\n<p>@param str [String] string …\n"],["str","Parslet::Accelerator","Parslet/Accelerator.html#method-i-str","(variable, *constraints)","<p>Returns a match expression that will match `str` parslet atoms.\n<p>@return [Parslet::Accelerator::Expression] …\n"],["subtree","Parslet","Parslet.html#method-c-subtree","(symbol)","<p>Returns a placeholder for tree transformation patterns that will match  any\nkind of subtree.\n\n<pre>{ :expression ...</pre>\n"],["subtree","Parslet","Parslet.html#method-i-subtree","(symbol)","<p>Returns a placeholder for tree transformation patterns that will match  any\nkind of subtree.\n\n<pre>{ :expression ...</pre>\n"],["succ","Parslet::Atoms::Base","Parslet/Atoms/Base.html#method-i-succ","(result)","<p>Produces an instance of Success and returns it.\n"],["succ","Parslet::Atoms::Context","Parslet/Atoms/Context.html#method-i-succ","(*args)","<p>Report a successful parse. @see ErrorReporter::Contextual\n"],["succ","Parslet::ErrorReporter::Contextual","Parslet/ErrorReporter/Contextual.html#method-i-succ","(source)","<p>A sequence expression successfully parsed, reset all errors reported for\nprevious expressions in the …\n"],["succ","Parslet::ErrorReporter::Deepest","Parslet/ErrorReporter/Deepest.html#method-i-succ","(source)","<p>Notification that an expression successfully parsed not used, see\nErrorReporter::Contextual\n"],["succ","Parslet::ErrorReporter::Tree","Parslet/ErrorReporter/Tree.html#method-i-succ","(source)","<p>Notification that an expression successfully parsed not used, see\nErrorReporter::Contextual\n"],["to_citrus","Parslet::Parser","Parslet/Parser.html#method-i-to_citrus","()","<p>Exports the current parser instance as a string in the Citrus dialect.\n<p>Example:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;parslet/export&#39;</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["to_f","Parslet::Slice","Parslet/Slice.html#method-i-to_f","()",""],["to_i","Parslet::Slice","Parslet/Slice.html#method-i-to_i","()",""],["to_int","Parslet::Slice","Parslet/Slice.html#method-i-to_int","()",""],["to_parslet","Parslet::Expression","Parslet/Expression.html#method-i-to_parslet","()","<p>Turns this expression into a parslet.\n"],["to_s","Parslet::Atoms::Base","Parslet/Atoms/Base.html#method-i-to_s","(outer_prec=OUTER)",""],["to_s","Parslet::Cause","Parslet/Cause.html#method-i-to_s","()",""],["to_s","Parslet::Slice","Parslet/Slice.html#method-i-to_s","()",""],["to_s_inner","Parslet::Atoms::Alternative","Parslet/Atoms/Alternative.html#method-i-to_s_inner","(prec)",""],["to_s_inner","Parslet::Atoms::Capture","Parslet/Atoms/Capture.html#method-i-to_s_inner","(prec)",""],["to_s_inner","Parslet::Atoms::Dynamic","Parslet/Atoms/Dynamic.html#method-i-to_s_inner","(prec)",""],["to_s_inner","Parslet::Atoms::Entity","Parslet/Atoms/Entity.html#method-i-to_s_inner","(prec)",""],["to_s_inner","Parslet::Atoms::Infix","Parslet/Atoms/Infix.html#method-i-to_s_inner","(prec)",""],["to_s_inner","Parslet::Atoms::Lookahead","Parslet/Atoms/Lookahead.html#method-i-to_s_inner","(prec)",""],["to_s_inner","Parslet::Atoms::Named","Parslet/Atoms/Named.html#method-i-to_s_inner","(prec)",""],["to_s_inner","Parslet::Atoms::Re","Parslet/Atoms/Re.html#method-i-to_s_inner","(prec)",""],["to_s_inner","Parslet::Atoms::Repetition","Parslet/Atoms/Repetition.html#method-i-to_s_inner","(prec)",""],["to_s_inner","Parslet::Atoms::Scope","Parslet/Atoms/Scope.html#method-i-to_s_inner","(prec)",""],["to_s_inner","Parslet::Atoms::Sequence","Parslet/Atoms/Sequence.html#method-i-to_s_inner","(prec)",""],["to_s_inner","Parslet::Atoms::Str","Parslet/Atoms/Str.html#method-i-to_s_inner","(prec)",""],["to_s_inner","Parslet::Parser","Parslet/Parser.html#method-i-to_s_inner","(prec)",""],["to_slice","Parslet::Slice","Parslet/Slice.html#method-i-to_slice","()",""],["to_str","Parslet::Slice","Parslet/Slice.html#method-i-to_str","()","<p>Conversion operators —————————————————–\n"],["to_sym","Parslet::Slice","Parslet/Slice.html#method-i-to_sym","()",""],["to_treetop","Parslet::Parser","Parslet/Parser.html#method-i-to_treetop","()","<p>Exports the current parser instance as a string in the Treetop dialect.\n<p>Example:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;parslet/export&#39;</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["transform","Parslet::Accelerator::Application","Parslet/Accelerator/Application.html#method-i-transform","(atom)",""],["transform","Parslet::Expression","Parslet/Expression.html#method-i-transform","(tree)","<p>Transforms the parse tree into a parslet expression.\n"],["transform_elt","Parslet::Transform","Parslet/Transform.html#method-i-transform_elt","(elt, context)","<p>@api private\n"],["try","Parslet::Atoms::Alternative","Parslet/Atoms/Alternative.html#method-i-try","(source, context, consume_all)",""],["try","Parslet::Atoms::Base","Parslet/Atoms/Base.html#method-i-try","(source, context, consume_all)","<p>Override this in your Atoms::Base subclasses to implement parsing\nbehaviour.\n"],["try","Parslet::Atoms::Dynamic","Parslet/Atoms/Dynamic.html#method-i-try","(source, context, consume_all)",""],["try","Parslet::Atoms::Entity","Parslet/Atoms/Entity.html#method-i-try","(source, context, consume_all)",""],["try","Parslet::Atoms::Infix","Parslet/Atoms/Infix.html#method-i-try","(source, context, consume_all)",""],["try","Parslet::Atoms::Lookahead","Parslet/Atoms/Lookahead.html#method-i-try","(source, context, consume_all)",""],["try","Parslet::Atoms::Re","Parslet/Atoms/Re.html#method-i-try","(source, context, consume_all)",""],["try","Parslet::Atoms::Repetition","Parslet/Atoms/Repetition.html#method-i-try","(source, context, consume_all)",""],["try","Parslet::Atoms::Sequence","Parslet/Atoms/Sequence.html#method-i-try","(source, context, consume_all)",""],["try","Parslet::Atoms::Str","Parslet/Atoms/Str.html#method-i-try","(source, context, consume_all)",""],["try","Parslet::Parser","Parslet/Parser.html#method-i-try","(source, context, consume_all)",""],["try_bind","Parslet::Accelerator::Engine","Parslet/Accelerator/Engine.html#method-i-try_bind","(variable, value)",""],["try_with_cache","Parslet::Atoms::Context","Parslet/Atoms/Context.html#method-i-try_with_cache","(obj, source, consume_all)","<p>Caches a parse answer for obj at source.pos. Applying the same parslet at\none position of input always …\n"],["unwrap","Parslet::Atoms::Infix","Parslet/Atoms/Infix.html#method-i-unwrap","(expr)",""],["update_label","Parslet::ErrorReporter::Contextual","Parslet/ErrorReporter/Contextual.html#method-i-update_label","(label, bytepos)","<p>Update error message label if given label is more relevant. A label is more\nrelevant if the position …\n"],["variable_name","Parslet::Pattern::SubtreeBind","Parslet/Pattern/SubtreeBind.html#method-i-variable_name","()",""],["visit_alternative","Parslet::Accelerator::Application","Parslet/Accelerator/Application.html#method-i-visit_alternative","(alternatives)",""],["visit_alternative","Parslet::Accelerator::Apply","Parslet/Accelerator/Apply.html#method-i-visit_alternative","(alternatives)",""],["visit_alternative","Parslet::GraphvizVisitor","Parslet/GraphvizVisitor.html#method-i-visit_alternative","(alternatives)",""],["visit_alternative","Parslet::Parser::Visitors::Citrus","Parslet/Parser/Visitors/Citrus.html#method-i-visit_alternative","(alternatives)",""],["visit_alternative","Parslet::Parser::Visitors::Treetop","Parslet/Parser/Visitors/Treetop.html#method-i-visit_alternative","(alternatives)",""],["visit_entity","Parslet::Accelerator::Application","Parslet/Accelerator/Application.html#method-i-visit_entity","(name, block)",""],["visit_entity","Parslet::Accelerator::Apply","Parslet/Accelerator/Apply.html#method-i-visit_entity","(name, block)",""],["visit_entity","Parslet::GraphvizVisitor","Parslet/GraphvizVisitor.html#method-i-visit_entity","(name, block)",""],["visit_entity","Parslet::Parser::Visitors::Citrus","Parslet/Parser/Visitors/Citrus.html#method-i-visit_entity","(name, block)",""],["visit_lookahead","Parslet::Accelerator::Application","Parslet/Accelerator/Application.html#method-i-visit_lookahead","(positive, atom)",""],["visit_lookahead","Parslet::Accelerator::Apply","Parslet/Accelerator/Apply.html#method-i-visit_lookahead","(positive, atom)",""],["visit_lookahead","Parslet::GraphvizVisitor","Parslet/GraphvizVisitor.html#method-i-visit_lookahead","(positive, atom)",""],["visit_lookahead","Parslet::Parser::Visitors::Citrus","Parslet/Parser/Visitors/Citrus.html#method-i-visit_lookahead","(positive, bound_parslet)",""],["visit_named","Parslet::Accelerator::Application","Parslet/Accelerator/Application.html#method-i-visit_named","(name, atom)",""],["visit_named","Parslet::Accelerator::Apply","Parslet/Accelerator/Apply.html#method-i-visit_named","(name, atom)",""],["visit_named","Parslet::GraphvizVisitor","Parslet/GraphvizVisitor.html#method-i-visit_named","(name, atom)",""],["visit_named","Parslet::Parser::Visitors::Citrus","Parslet/Parser/Visitors/Citrus.html#method-i-visit_named","(name, parslet)",""],["visit_parser","Parslet::Accelerator::Application","Parslet/Accelerator/Application.html#method-i-visit_parser","(root)",""],["visit_parser","Parslet::Accelerator::Apply","Parslet/Accelerator/Apply.html#method-i-visit_parser","(root)",""],["visit_parser","Parslet::GraphvizVisitor","Parslet/GraphvizVisitor.html#method-i-visit_parser","(root)",""],["visit_re","Parslet::Accelerator::Application","Parslet/Accelerator/Application.html#method-i-visit_re","(regexp)",""],["visit_re","Parslet::Accelerator::Apply","Parslet/Accelerator/Apply.html#method-i-visit_re","(regexp)",""],["visit_re","Parslet::GraphvizVisitor","Parslet/GraphvizVisitor.html#method-i-visit_re","(regexp)",""],["visit_re","Parslet::Parser::Visitors::Citrus","Parslet/Parser/Visitors/Citrus.html#method-i-visit_re","(match)",""],["visit_repetition","Parslet::Accelerator::Application","Parslet/Accelerator/Application.html#method-i-visit_repetition","(tag, min, max, atom)",""],["visit_repetition","Parslet::Accelerator::Apply","Parslet/Accelerator/Apply.html#method-i-visit_repetition","(tag, min, max, atom)",""],["visit_repetition","Parslet::GraphvizVisitor","Parslet/GraphvizVisitor.html#method-i-visit_repetition","(tag, min, max, atom)",""],["visit_repetition","Parslet::Parser::Visitors::Citrus","Parslet/Parser/Visitors/Citrus.html#method-i-visit_repetition","(tag, min, max, parslet)",""],["visit_repetition","Parslet::Parser::Visitors::Treetop","Parslet/Parser/Visitors/Treetop.html#method-i-visit_repetition","(tag, min, max, parslet)",""],["visit_sequence","Parslet::Accelerator::Application","Parslet/Accelerator/Application.html#method-i-visit_sequence","(sequence)",""],["visit_sequence","Parslet::Accelerator::Apply","Parslet/Accelerator/Apply.html#method-i-visit_sequence","(sequence)",""],["visit_sequence","Parslet::GraphvizVisitor","Parslet/GraphvizVisitor.html#method-i-visit_sequence","(sequence)",""],["visit_sequence","Parslet::Parser::Visitors::Citrus","Parslet/Parser/Visitors/Citrus.html#method-i-visit_sequence","(parslets)",""],["visit_str","Parslet::Accelerator::Application","Parslet/Accelerator/Application.html#method-i-visit_str","(str)",""],["visit_str","Parslet::Accelerator::Apply","Parslet/Accelerator/Apply.html#method-i-visit_str","(str)",""],["visit_str","Parslet::GraphvizVisitor","Parslet/GraphvizVisitor.html#method-i-visit_str","(str)",""],["visit_str","Parslet::Parser::Visitors::Citrus","Parslet/Parser/Visitors/Citrus.html#method-i-visit_str","(str)",""],["warn_about_duplicate_keys","Parslet::Atoms::CanFlatten","Parslet/Atoms/CanFlatten.html#method-i-warn_about_duplicate_keys","(h1, h2)","<p>That annoying warning &#39;Duplicate subtrees while merging result&#39;\ncomes  from here. You should …\n"],["|","Parslet::Accelerator::Expression","Parslet/Accelerator/Expression.html#method-i-7C","(other_expr)","<p>@return [Expression]\n"],["|","Parslet::Atoms::Alternative","Parslet/Atoms/Alternative.html#method-i-7C","(parslet)","<p>+\n"],["|","Parslet::Atoms::DSL","Parslet/Atoms/DSL.html#method-i-7C","(parslet)","<p>Chains two parslet atoms together to express alternation. A match will\nalways be attempted with the parslet …\n"],["README","","README.html","","<p>INTRODUCTION\n<p>Parslet makes developing complex parsers easy. It does so by\n<p>providing the best error reporting …\n"]]}}