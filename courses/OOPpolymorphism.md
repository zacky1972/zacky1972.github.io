---
title: オブジェクト指向プログラミング〜ポリモーフィズム
layout: default
---
# オブジェクト指向プログラミング〜ポリモーフィズム

## クラスと属性・操作

クラスは，クラス名の他に，属性と操作を持ちます。

* クラス名: クラスの名称
* 属性(attribute): クラスが持っている性質。属性の型と属性名を持ちます。例: 整数型の id という属性
* 操作(operation): クラスができる機能。操作は，その操作が返す型と，操作名と，必要に応じて引数を持ちます。例: 整数型を返す add という操作。add の引数は整数型の a と b。

UML ではクラスを表す矩形の中を3つに区切って，上から順にクラス名，属性，操作の順番で表記します。

クラスの矩形の中を2つに区切った時には，上から順にクラス名，属性の順で表記して，操作を省略します。

クラスの矩形の中が1つしかない時にはクラス名だけを表記します。

クラス名と操作を表記して，属性を省略したい時には，クラスの矩形の中を3つに区切って真ん中の属性を書くべき領域を空白にします。

UML では属性・操作という言葉を使いますが，プログラミング言語では異なる言葉を使うことがあります。

* Ruby の場合:
	* 属性: インスタンス変数(instance variable)
	* 操作: メソッド(method)

## 言葉の確認 

下記の概念がわからなかったら，モデリングの Lesson1 を復習してください。

* 汎化
* スーパークラス
* サブクラス

## 継承とは？

2つのクラスに汎化関係が成立している時には，スーパークラスにある性質をサブクラスが継承しています。どういうことかというと，サブクラスはスーパークラスが持っている属性と操作を継承しているということです。

この性質により次の性質が成立します。

* サブクラスはスーパークラスの代わりができる
* サブクラスのインスタンスはスーパークラスの変数に代入できる

ただし，逆はできないかもしれないです。もちろん，できる場合もあります。その理由は，サブクラスが機能を拡張している，すなわち新たな操作を足している場合には，スーパークラスはサブクラスの代わりができないからです。

## ポリモーフィズム

次のようなペット型ロボットの例を考えます。

* スーパークラス: ペット型ロボット
* サブクラス: ネコ型，イヌ型

モデリング演習の Lesson4 ，汎化と関連の組み合わせを復習しながら，

* 関連元: Client
* 関連先: ペット型ロボット
* Client はペット型ロボットを使う

Client というのは，顧客のことですが，ここではその意味から転じて，利用する側のプログラムのことを指します。

ここで，操作として「喜ぶ」「怒る」を定義したとします。

* イヌ型ロボットは，怒る時に，ほえる
* ネコ型ロボットは，怒る時に，ひっかく
* イヌ型ロボットは，喜ぶ時に，しっぽを振る
* ネコ型ロボットは，喜ぶ時に，のどを鳴らす

という具合に同じメソッドを実行した時の振る舞いが異なります。

このようなことを，ポリモーフィズム (polymorphism) といいます。

## ポリモーフィズムのサンプルプログラム

先ほどのクラス図は，Ruby の場合，次のように書きます。

```ruby
# Pet sample

class Pet
	def getAngry
	end
end

class Cat < Pet
	def getAngry
		"ネコがひっかく"
	end
end

pet = Cat.new
puts pet.getAngry
```

ここで，Client のコードは pet = ... 以降です。

このプログラムを実行すると，「ひっかく」と表示されます。

ここで新たに次のコードを Client の前に足してください。

```ruby
class Dog < Pet
	def getAngry
		"イヌがほえる"
	end
end
```

その上で，Client のコードの Cat.new を Dog.new に変更して実行すると，「ほえる」と表示されます。

ここまでまとめると，次のようなコードになります。

```ruby
# Pet sample

class Pet
	def getAngry
	end
end

class Cat < Pet
	def getAngry
		"ネコがひっかく"
	end
end

class Dog < Pet
	def getAngry
		"イヌがほえる"
	end
end

pet = Cat.new
puts pet.getAngry
pet = Dog.new
puts pet.getAngry
```


なんでポリモーフィズムがあるかというと，どのサブクラスであったとしても，Client のコードはそのままで実行できるという利点があるからです。この利点により，コードの再利用性が高まるので，ソフトウェア開発の生産性が高くなります。

## 演習問題 ポリモーフィズム

このプログラムに，喜ぶ: rejoice というメソッドを追加してみてください。ただし Pet クラスにも rejoice メソッドを追加する必要がある点に注意してください。


